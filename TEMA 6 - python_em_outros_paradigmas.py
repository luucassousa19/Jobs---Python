# -*- coding: utf-8 -*-
"""TEMA 6 - Python em Outros Paradigmas.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pS-0jsbfYYJFg9V7RGCqaU42ebPP4vhO

# **MÓDULO 1**

Aplicando programação funcional com Python

**Mutabilidade**

Mutabilidade em Python refere-se à capacidade de um objeto de ser alterado após sua criação. Em Python, os objetos podem ser classificados em duas categorias principais com base na mutabilidade: mutáveis e imutáveis.

**- Exemplos de Objetos Mutáveis:** Listas, Dicionarios, Conjuntos.
São aqueles que podem ser modificados após a criação. Isso significa que você pode alterar seus elementos ou atributos diretamente sem precisar criar um novo objeto.

**- Exemplos de Objetos Imutáveis:** Tuplas, Strings, Números.  São aqueles que não podem ser alterados após a criação. Qualquer tentativa de modificar um objeto imutável resultará na criação de um novo objeto.


**Por Que a Mutabilidade Importa?**
A mutabilidade é importante em Python porque afeta como os dados são manipulados e armazenados na memória. Aqui estão algumas considerações importantes:

**Eficácia de Memória:** Objetos mutáveis podem ser modificados in-place, economizando memória e aumentando a eficiência.
Objetos imutáveis, por outro lado, geralmente necessitam da criação de novos objetos para representar modificações.

**Segurança:** Objetos imutáveis são frequentemente usados em contextos onde a consistência dos dados é crítica, como em chaves de dicionários ou valores armazenados em conjuntos.

**Comportamento em Funções:** Funções que recebem objetos mutáveis como argumentos podem modificar esses objetos diretamente, afetando seu estado fora do escopo da função. Funções que recebem objetos imutáveis não podem modificar o objeto original, garantindo que o estado do objeto fora da função permaneça inalterado.
"""

# MUTABILIDADE
def sum(numeros):
  total = 0
  for numero in numeros:
    total += numero
    return total

  print(sum([2,4,6,8,10]))

# EXEMPLO 2
def sum(numeros):
  if not numeros:
    return 0
  primeiro = numeros[0]
  resto = numeros[1:]
  return primeiro + sum(resto)


  print(sum([2,4,6,8,10]))

# EXEMPLO 3
print('\nterceiro exemplo')
lista = ['Ferrari']
nova_lista = lista + ['Porsche']
print(nova_lista)

# EXEMPLO 4
print('\nquarto exemplo')
import operator
print(operator.add(10,20))

# EXEMPLO 5
print('\nquinto exemplo')
from functools import reduce
print(reduce(operator.add, [10,20]))
print(reduce(operator.concat, ['Aprendendo Reduce!']))

"""**EXEMPLOS DE PARTIAL**

O **partial** no Python é uma função do **módulo functools** que permite fixar um ou mais argumentos de uma função, criando uma nova função com esses argumentos pré-preenchidos. Isso é útil para criar versões especializadas de funções existentes sem precisar definir novas funções explicitamente.

- **Como Funciona o partial:**O partial funciona "pré-preenchendo" alguns dos argumentos de uma função, deixando os restantes para serem fornecidos mais tarde. Ele retorna um novo objeto de função.
"""

# EXEMPLO PARTIAL
import operator
from functools import partial
adiciona_um = partial(operator.add, 1)

print(adiciona_um(5))

# EXEMPLO 2
print('\nsegundo exemplo')
import collections
from operator import attrgetter
pessoa = collections.namedtuple('pessoa', 'nome idade')
pessoas = [pessoa('Joao',40), pessoa('Ana',20), pessoa('Renata',25)]

print(sorted(pessoas, key=attrgetter('nome')))
print(sorted(pessoas, key=attrgetter('idade')))

# EXEMPLO 3
print('\nterceiro exemplo')
from functools import partial
sort_nome = partial(sorted, key=attrgetter('nome'))
sort_idade = partial(sorted, key=attrgetter('idade'))

print(sort_nome(pessoas))
print(sort_idade(pessoas))

# TRATANDO UMA API
usuario = {
    'nome' : 'Joao',
    'redes': [{
        'nome':'facebook',
        'imagem_profile':"",
        'imagem_capa':'imagem1',
    },{
        'nome':'twitter',
        'imagem_profile':'imagem2',
        'imagem_capa':""
    }]
}

# RETORNA A IMAGEM DO PROFILE
def get_imagem_profile(usuario):
  for rede in usuario['redes']:
    if rede[imagem_profile]:
      return rede['imagem_profile']
  return 'defaut'

# RETORNA A IMAGEM DE CAPA
def get_imagem_capa(usuario):
  for rede in usuario['redes']:
    if rede[imagem_capa]:
      return rede['imagem_capa']
  return 'defaut'

# UTILIZANDO PARTIAL
from functools import partial
def get_imagem(qual_imagem,usuario):
  for rede in usuario['redes']:
    if rede[qual_imagem]:
      return rede[qual_imagem]
  return 'defaut'

get_imagem_profile = partial(get_imagem,'imagem_profile')
get_imagem_capa = partial(get_imagem,'imagem_capa')

print('\nsaida partial final')
print(get_imagem_profile(usuario))
print(get_imagem_capa(usuario))

"""EXERCICIOS

- programação funcional em Python
- **lambda x::** Define uma função anônima que recebe um argumento x.
- **str.upper(x):** Converte o argumento x para letras maiúsculas utilizando o método upper da classe str.

- **map**: em Python é uma função de ordem superior que aplica uma função a todos os itens de um iterável (como uma lista ou tupla) e retorna um novo iterável contendo os resultados.

- **reduce**: faz parte do módulo **functools** em Python e é usada para aplicar uma função cumulativa a um iterável, reduzindo-o a um único valor. reduce aplica a função fornecida de maneira sequencial, acumulando o resultado em cada passo.
"""

# EXEMPLO - Implementar uma solução através de programação funcional para transformar os nomes em maiusculos

#LISTA
veiculos = ['aviao', 'carro', 'navio', 'onibus']

f_maiuscula = lambda x: str.upper(x)
nomes_maisculos = list(map(f_maiuscula, veiculos))

print(f'nomes maisculos = {nomes_maisculos}')

# EXERCICIO 1) Implementar uma solução através da programação funcional para imprimir apenas os numeros pares.
lista = [0,1,1,2,3,5,8,13,21,34]

fTesteParidade = lambda x: x % 2 == 0
print(f'Teste de fTesteParidade(5) = {fTesteParidade(5)}')

pares = list(filter(fTesteParidade, lista))

print(f"Lista de números pares = {pares}")

# EXERCICIO 2) Implementar uma solução através da programação funcional para arrendondar os valores da lista
              # de números na mesma ordem da lista de precisão

lista_numeros = [9.56783, 7.57568, 3.00914, 6.2321]
lista_precisao = [2, 2, 3, 3]

arredondamento = lambda x,y: round(x,y)
resultado = list(map(arredondamento, lista_numeros, lista_precisao))

print(resultado)

# EXERCICIO 3) Implementar uma solução através da programação funcional para somar todos os elementos da lista

from functools import reduce

f_soma = lambda x,y: x + y
numeros = [1,2,3,4,5,6,7,8,9,10]

resultado = reduce(f_soma, numeros)
print(resultado)

"""# **MÓDULO 2**

- Utilizando Python na programação concorrente
"""

import threading
import time

# Exemplo de função sem parametros
def funcao():
  for i in range(3):
    print(i, 'Executando a thread')
    time.sleep(1)

print('Iniciando o programa!')
threading.Thread(target=funcao).start()
print('Finalizando o programa!')

# Exemplo 2 função com parametros
def funcao(mensagem):
  for i in range(3):
    print(i, mensagem)
    time.sleep(1)

print('Iniciando o programa!')
x = threading.Thread(target=funcao, args=('Executando!',))
x.start()
print('Finalizando o programa!')

# Exemplo 3
# SINCRONIZANDO THREADS

ls = []

def contador1(n):
  for i in range(1,n+1):
    print(i)
    ls.append(i)
    time.sleep(0.4)

def contador2(n):
  for i in range(6,n+1):
    print(i)
    ls.append(i)
    time.sleep(0.5)

x = threading.Thread(target=contador1, args=(5,))
x.start()

x.join()

y = threading.Thread(target=contador1, args=(10,))
y.start()

#x.join()
y.join()

print(ls)

import threading
import urllib3
import time

start = time.time()
urls = [
    "http://www.google.com",
    "http://www.Apple.com",
    "http://www.Microsoft.com",
    "http://www.instagram.com"
]

# Inicializa o pool manager do urllib3
http = urllib3.PoolManager()

def chama_url(url):
    response = http.request('GET', url)
    the_page = response.data
    print("'%s' carregado em %ss" % (url, (time.time() - start)))
    #print(the_page)

threads = [threading.Thread(target=chama_url, args=(url,)) for url in urls]

for thread in threads:
    thread.start()
for thread in threads:
    thread.join()

print("Elapsed Time: %s" % (time.time() - start))

"""**EXERCICIOS**"""

# EXEMPLO 1
from time import sleep
from threading import Thread

def tarefa(tempo_espera, mensagem):
  print(f'\nIniciando a tarefa {mensagem}')
  sleep(tempo_espera)
  print(f'\nConclusão da tarefa {mensagem}')

thread = Thread(target=tarefa, args=(2, 'Thread em execução'))
thread.start()
print('\nAguardando pela execução da Thread...')
thread.join()
print("A execução foi concluída!")

# Exercicio 1) Implementar uma Thread que:
# - Inicie a execução de duas Threads
# - Coloque a primeira e a segunda threads para esperar, respectivamente, 3 e 2 segundos
# - Informe a ordem da Execução das threads

import threading
import time

# Função que será executada pela primeira thread
def thread_1():
    print("Tarefa 1 iniciada")
    time.sleep(3)
    print("Tarefa 1 terminada")

# Função que será executada pela segunda thread
def thread_2():
    print("Tarefa 2 iniciada")
    time.sleep(2)
    print("Tarefa 2 terminada")

# Função principal para iniciar as threads e informar a ordem de execução
def main():
    # Criação das threads
    t1 = threading.Thread(target=thread_1)
    t2 = threading.Thread(target=thread_2)

    # Início das threads
    t1.start()
    t2.start()

    # Espera a conclusão das threads
    t1.join()
    t2.join()

    print("Execução das Tarefas finalizadas com sucesso")

if __name__ == "__main__":
    main()

"""***Explicação do código acima***

**Definição das Funções das Threads:**

- **thread_1:** Espera 3 segundos e imprime mensagens indicando início e término.
- **thread_2:** Espera 2 segundos e imprime mensagens indicando início e término.

**Função Principal main:**

- Cria duas threads t1 e t2 com as funções thread_1 e thread_2 como alvos.
- Inicia as threads com t1.start() e t2.start().
- Usa t1.join() e t2.join() para esperar a conclusão das threads antes de prosseguir.

**Execução do Código:**

- Quando o script é executado, a função main é chamada.
- As threads são iniciadas e aguardam o tempo especificado.
- A ordem de execução das threads é informada pelas mensagens impressas.
"""

# Exercicio 2) Implementar uma Thread que:
# - Inicie a execução de duas Threads
# - A primeira deve calcular o cubo de um número
# - A segunda deve calcular o quadrado de um número
# - Coloque a primeira e a segunda threads para esperar respectivamente, 3 e 2 segundos
# - Informe a ordem da execução das threads

import threading
import time

def calcular_cubo(numero):
    print("Thread para calcular o cubo iniciada")
    time.sleep(3)
    resultado = numero ** 3
    print(f"O cubo de {numero} é {resultado}")
    print("Thread para calcular o cubo terminada")

def calcular_quadrado(numero):
    print("Thread para calcular o quadrado iniciada")
    time.sleep(2)
    resultado = numero ** 2
    print(f"O quadrado de {numero} é {resultado}")
    print("Thread para calcular o quadrado terminada")

def main():
    numero = 5  # Você pode alterar este número para testar com outros valores

    # Criação das threads
    t1 = threading.Thread(target=calcular_cubo, args=(numero,))
    t2 = threading.Thread(target=calcular_quadrado, args=(numero,))

    # Início das threads
    t1.start()
    t2.start()

    # Espera a conclusão das threads
    t1.join()
    t2.join()

    print("Execução das threads finalizada")

if __name__ == "__main__":
    main()

"""**Definição das Funções das Threads:**

- **calcular_cubo:** Espera 3 segundos, calcula o cubo do número e imprime o resultado.
- **calcular_quadrado:** Espera 2 segundos, calcula o quadrado do número e imprime o resultado.

**Função Principal main:**

- Define um número (numero) para ser usado nos cálculos.
- Cria duas threads t1 e t2 para calcular o cubo e o quadrado, respectivamente.
- Inicia as threads com t1.start() e t2.start().
- Usa t1.join() e t2.join() para esperar a conclusão das threads antes de prosseguir.

**Execução do Código:**

- Quando o script é executado, a função main é chamada.
- As threads são iniciadas e aguardam o tempo especificado antes de realizar os cálculos.
- A ordem de execução das threads é informada pelas mensagens impressas.

# **MÓDULO 3**

Desenvolvendo aplicações Web com Python

**obs:** Todas as atividades desse modulo devem ser executada no VS Code
"""

# EXEMPLO 1) Implementar uma solução com Flask que faça:
# - Exiba a mensagem "Pagina principal" no endereço raiz de uma pagina web
# - Exiba a mensagem "Olá, Mundo!" no endereço "/ola/" de uma pagina web
# - Exiba a mensagem "Olá, usuário!" no endereço "/ola/nome_do_usuario" de uma pagina web
# pip install flask
# Feito teste no VS Code

from flask import Flask

app = Flask(__name__)

# Rota para a página principal
@app.route('/')
def pagina_principal():
    return "Pagina principal"

# Rota para o endereço
@app.route('/')
def index():
    return "Pagina Principal"

@app.route('/ola/')
@app.route('/ola/<nome>')

def ola_mundo(nome="mundo"):
    return "Olá, " + nome +"!"

if __name__ == '__main__':
    app.run()

""" * Serving Flask app '__main__'

 * Debug mode: off

WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.

 * Running on http://127.0.0.1:5000

**Press CTRL+C to quit**
- 127.0.0.1 - - [20/Jun/2024 14:26:20] "GET / HTTP/1.1" 200 -
- 127.0.0.1 - - [20/Jun/2024 14:26:20] "GET /favicon.ico HTTP/1.1" 404 -
- 127.0.0.1 - - [20/Jun/2024 14:26:37] "GET /ola/ HTTP/1.1" 200 -
"""

# EXERCICIO 1) Implementar uma solução com Flask que faça:
# - Exiba "Olá Progamadores", no endereço raiz de uma pagina web e apareça o link "/user/usuario"
# - Exiba "Olá Usuário!" no endereço "/user/" e exiba a mensagem "Altera o endereço do browser e recarregue a pagina"
# - Exiba "Olá, nome_usuario!" no endereço "/user/nome_do_usuario" de uma parina web

from flask import Flask
app = Flask(__name__)

# Rota para o endereço
@app.route('/')
def cumprimento():
    boas_vidas = '<h1>Olá, Programadores!</h1>'
    link = '<p><a href="user/usuario">Clique Aqui!</a></p>'
    return boas_vidas + link

@app.route('/user/')
@app.route('/user/<nome>')

def user(nome="Usuario"):
    personalizar = f'<h1>Olá, {nome}!</h1>'
    instrucao = '<p>Altere o nome no <em> endereço do browser</em> \ e recarregue a página.</p>'
    return personalizar + instrucao

if __name__ == '__main__':
    app.run()

""" * Serving Flask app '__main__'

 * Debug mode: off

WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.

 * Running on http://127.0.0.1:5000

Press CTRL+C to quit

- 127.0.0.1 - - [20/Jun/2024 14:47:05] "GET / HTTP/1.1" 200 -
- 127.0.0.1 - - [20/Jun/2024 14:47:08] "GET /user/usuario HTTP/1.1" 200 -
- 127.0.0.1 - - [20/Jun/2024 14:47:21] "GET /user/ HTTP/1.1" 200 -
- 127.0.0.1 - - [20/Jun/2024 14:47:27] "GET / HTTP/1.1" 200 -
- 127.0.0.1 - - [20/Jun/2024 14:47:31] "GET /user/usuario HTTP/1.1" 200 -
"""

# EXERCICIO 2) Implementar uma solução com Flask que faça:
# - Exiba "Olá Progamadores", no endereço raiz de uma pagina web e apareça a mensagem "Entre com dois números"
# - Exiba "0.0" no endereço "/somar/"
# - Exiba "30.0" no endereço "/somar/10/20" de uma pagina web

from flask import Flask
app = Flask(__name__)

# Rota para o endereço
@app.route('/')
def cumprimento():
    boas_vidas = '<h1>Olá, Programadores!</h1>'
    instr = '<p>Entre com dois números</p>'
    return boas_vidas + instr

@app.route('/somar/')
@app.route('/somar/<num01>/<num02>')

def soma(num01=0, num02=0):
  resultado = float(num01) + float(num02)
  return str(resultado)

if __name__ == '__main__':
    app.run()

"""# **MÓDULO 4**

Aplicando Python para o tratamento de dados
"""

# EXEMPLO 1

from sklearn.tree import DecisionTreeClassifier

# Definição das constantes
lisa = 1
irregular = 0
pera = 1
laranja = 0

# Criação do conjunto de dados de treinamento
pomar = [[120, lisa], [140, lisa], [180, irregular], [200, irregular]]
resultado = [pera, pera, laranja, laranja]

# Criação e treinamento do classificador de árvore de decisão
cfl = DecisionTreeClassifier()
cfl = cfl.fit(pomar, resultado)

# Nova fruta para classificação
peso = 220
superficie = 1

# Classificação da nova fruta
resultadousu = cfl.predict([[peso, superficie]])

# Interpretação do resultado
if resultadousu[0] == 1:
    print('Pera')
else:
    print('Laranja')

"""**Explicação das etapas do código acima:**

**from sklearn.tree import DecisionTreeClassifier:** Importa o DecisionTreeClassifier da biblioteca scikit-learn, que será usado para criar e treinar um classificador de árvore de decisão.

**lisa = 1 irregular = 0 pera = 1 laranja = 0:** Define constantes para representar diferentes características das frutas
- lisa e irregular são usadas para indicar a textura da fruta.
- pera e laranja são usadas para representar os tipos de fruta.


**pomar = [[120, lisa], [140, lisa], [180, irregular], [200, irregular]] resultado = [pera, pera, laranja, laranja]**: Cria o conjunto de dados de treinamento:
- pomar é uma lista de listas, onde cada sublista contém dois valores: o peso da fruta e sua textura.
- [120, lisa] representa uma fruta com peso 120 e textura lisa.
- [180, irregular] representa uma fruta com peso 180 e textura irregular.
- resultado é uma lista que contém as etiquetas correspondentes para cada fruta no pomar
- As duas primeiras frutas são pera (1) e as duas últimas são laranja (0).


**cfl = DecisionTreeClassifier() cfl = cfl.fit(pomar, resultado)**: Cria uma instância do DecisionTreeClassifier e a treina com o conjunto de dados de treinamento
- DecisionTreeClassifier() cria o classificador.
- cfl.fit(pomar, resultado) treina o classificador usando os dados de pomar e suas etiquetas em resultado.

**peso = 220 superficie = 1**: Define as características da nova fruta que será classificada
- peso = 220 indica que a nova fruta tem um peso de 220.
- superficie = 1 indica que a nova fruta tem uma textura lisa.

**resultadousu = cfl.predict([[peso, superficie]])**: Classifica a nova fruta usando o classificador treinado
- cfl.predict([[peso, superficie]]) retorna a previsão do classificador para a nova fruta com as características fornecidas. A previsão é armazenada em resultadousu.

**if resultadousu[0] == 1: print('Pera') else: print('Laranja')**: Interpreta o resultado da previsão e imprime o tipo de fruta
- resultadousu[0] acessa a primeira (e única) previsão no array resultadousu.
- Se resultadousu[0] for igual a 1, imprime 'Pera'.
- Caso contrário, imprime 'Laranja'.


"""

# EXEMPLO 2 - Implementar uma solução que estuda o comportamento de uma série temporal com REGRESSÃO LINEAR
import numpy as np
from sklearn.linear_model import LinearRegression
import matplotlib.pyplot as plt

x = np.array([5, 10, 15, 20, 25, 30]).reshape((-1, 1))
y = np.array([6, 12, 14, 23, 27, 32])

model = LinearRegression().fit(x,y)

#Predict a response and print it:
y_pred = model.predict(x)
print('Dados do teste:', y, sep='\n')
print('Dados da predição:', y_pred, sep='\n')

plt.scatter(x, y,c="blue")
plt.plot(x, y_pred, c="red")
plt.legend(['Predição', 'Real'])
plt.show()

# EXERCICIO 1) - Carregar dados da base load_digits. Informar a quantidade de dados.
from sklearn.datasets import load_digits
digitos = load_digits()

#Existem 1797 imagens, sendo que cada uma tem uma dimensão 8x8 = 64
print("Shape dos dados de imagens: {}".format(digitos.data.shape))

#Apresentar o total de dados rotulados com inteiros de 0 a 9
print("Shape dos dados rotulados: {}".format(digitos.target.shape))

# EXERCICIO 2) Visualizar os dados que foram carregados
import numpy as np
import matplotlib.pyplot as plt

plt.figure(figsize=(14,4))
for index, (imagem, rotulo) in enumerate(zip(digitos.data[0:5], digitos.target[0:5])):
  plt.subplot(1, 5, index + 1)
  plt.imshow(np.reshape(imagem, (8,8)),
             cmap=plt.cm.gray)

  plt.title('Treinamento:{}\n'.format(rotulo,fontsize = 15))

# EXERCICIO 3) Utilizar um modelo de regressão logistica

##TREINAMENTO
from sklearn.model_selection import train_test_split
x_treino, x_teste, y_treino, y_teste = train_test_split(digitos.data,
                                                        digitos.target,
                                                        test_size=0.25,
                                                        random_state=0)

from sklearn.linear_model import LogisticRegression
from sklearn.pipeline import make_pipeline
from sklearn.preprocessing import StandardScaler

pipe = make_pipeline(StandardScaler(),
                     LogisticRegression())
pipe.fit(x_treino, y_treino)

# EXERCICIO 4) Utilizar o modelo regressão logistica treinado para fazer classificação.
# PREDIÇÃO(Classificação)

previsto = pipe.predict(x_teste[0].reshape(1,-1))
real = y_teste[0]
print('previsto:{}; real:{}' .format(previsto[0], real))

