# -*- coding: utf-8 -*-
"""TEMA 5 - aulas_python_orientado_a_objetos.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JCc2jVfD6i0t0thIVdm7zE7-ZlrQb-Id

# **MODULO 1**

Aplicações do paradigma orientado a objetos
Conceitos de paradigma orientados a objetos

*   CLASSE é uma unidade lógica onde temos atributos e metodos
*   VARIAVEIS são agrupadas dentro de uma classe
*   METODOS são as funçoes que vao manipular os atributos


**Propriedades da PROGRAMAÇÃO ORIENTAA A OBJETO:**

- **ABSTRAÇÃO:** Modelo Reduzido;

- **ENCAPSULAMENTO:** Restringe o acesso a métodos e atributos en uma classe. No Python, isso é obtido usando métodos ou atributos privados usando sublinhado como prefixo, ou seja "_" simples ou "__" duplo;

- **HERANÇA:** Permite definir uma classe que herda todos os métodos e atributos de outra classe.

- **POLIMORFISMO:** Permite usar uma interface com diferente formas.


**Getters**
- **Função:** Recuperar o valor de um atributo.
- **Nome:** Geralmente começam com "get" seguido pelo nome do atributo.
- **Exemplo:** No código que você forneceu, o método get_nome é um getter.


**Setters**
- **Função:** Modificar o valor de um atributo.
- **Nome:** Geralmente começam com "set" seguido pelo nome do atributo.
- **Exemplo:** No código que você forneceu, o método set_nome é um setter
"""

#CRIANDO A CLASSE PESSOA
class Pessoa:

  def __init__(self, nome, ender):
    self.set_nome(nome)
    self.set_ender(ender)

  def set_nome(self, nome):
    self.nome=nome

  def set_ender(self, ender):
    self.ender=ender

  def get_nome(self):
    return self.nome

  def get_ender(self):
    return self.ender


# O código define uma classe Pessoa com os seguintes métodos:
# Construtor (__init__): inicializa os atributos nome e ender.
# Métodos set_nome e set_ender: definem os valores dos atributos nome e ender.
# Métodos get_nome e get_ender: retornam os valores dos atributos nome e ender.

# OBJETO PESSOA
pessoa1 = Pessoa("leticia","Rua domingos alvares 79")
pessoa2 = Pessoa("lucas","Rua dalmo rugani 31")

print(f'Nome: {pessoa1.get_nome()}, Endereço: {pessoa1.get_ender()}')
print(f'Nome: {pessoa2.get_nome()}, Endereço: {pessoa2.get_ender()}')



"""# **MODULO 2**

Agregação, classes e métodos estáticos

- **Decorador @classmethod:**
O método apartirAnoNascimento foi decorado com @classmethod, indicando que é um método de classe e recebe cls como primeiro argumento.

- **Decorador @staticmethod:**
O método ehMaiorIdade foi decorado com @staticmethod, indicando que é um método estático que não depende de nenhuma instância da classe.
"""

# Classe Salário

class Salario:
  def __init__(self, base, bonus):
    self.base = base
    self.bonus = bonus

  def salario_anual(self):
    return (self.base*12) + self.bonus

# Classe Empregado

class Empregado:
    def __init__(self, nome, idade, salario):
        self.nome = nome
        self.idade = idade
        self.salario = salario

    def salario_total(self):
        return self.salario.salario_anual()

# na chamada abaixo a base ´10000' e o bonus '700':
salario = Salario(10000, 700)
emp = Empregado('Lucas', 30, salario)
print(emp.salario_total())

from datetime import date

class Pessoa:
    def __init__(self, nome, idade):
        self.nome = nome
        self.idade = idade

    # Um método de classe para criar um objeto Pessoa através do ano de nascimento
    @classmethod
    def apartirAnoNascimento(cls, nome, ano):
        return cls(nome, date.today().year - ano)

    # Método Estático para verificar se é maior de idade
    @staticmethod
    def ehMaiorIdade(idade):
        return idade >= 18

# Criando instâncias de Pessoa
pessoa1 = Pessoa('Leticia', 28)
pessoa2 = Pessoa.apartirAnoNascimento('Lucas', 1994)

# Verificando se as pessoas são maiores de idade
print(pessoa1.nome, pessoa1.idade, Pessoa.ehMaiorIdade(pessoa1.idade))  # Saída: Leticia 26 True
print(pessoa2.nome, pessoa2.idade, Pessoa.ehMaiorIdade(pessoa2.idade))  # Saída: Lucas 18 True (considerando o ano atual como 2024)

# COMPOSIÇÃO
class Extrato:
  def __init__(self):
    self.transacoes = []

  def imprimir(self):
    for p in self.transacoes:
      print(p[0], p[1])

class Conta:
  def __init__(self, clientes, numero, saldo):
    self.clientes = clientes
    self.numero = numero
    self.saldo = saldo
    self.extrato = Extrato()

  def depositar(self, valor):
    self.saldo += valor
    self.extrato.transacoes.append(["DEPOSITO", valor])

  def sacar(self, valor):
    if self.saldo < valor:
      return False
    else:
      self.saldo -= valor
      self.extrato.transacoes.append(["SAQUE", valor])
      return True

# CHAMADA DO BLOCO ACIMA -- TESTE --
c1 = ("1111111111-11", "Leticia", "Avenida 7 de Setembro")
c2 = ("2222222222-22", "Lucas", "Rua Domingos alvares")

conta = Conta([c1,c2], 24237891, 2500.00)

conta.depositar(1000)
conta.sacar(500)
conta.extrato.imprimir()

"""# **MODULO 3**

Herança, polimorfismo e exceções
"""

# EXEMPLO DE HERANÇA
class  ClasseSomaMultiplica:
  def __init__(self, a, b):
    self.a = a
    self.b = b

  def somar(self):
    return self.a + self.b;

  def multiplica(self):
    return self.a * self.b;

class derivada(ClasseSomaMultiplica):
  def subtrair(self):
    return self.a - self.b;

  def dividir(self):
    return self.a / self.b;

d = derivada(10, 20)
print(f'A soma de 10 e 20 é {d.somar()}')
print(issubclass(derivada,ClasseSomaMultiplica))

# Exemplo simples de SOBRECARGA
def somar (x, y, z = 0):
  return x + y + z

print(somar(20, 30))
print(somar(20, 30, 50))

# Exemplo de POLIMORFISMO
class Argentina():
  def capital(self):
    print("Buenos Aires é a capital da Argentina")
  def lingua_oficial(self):
    print("O espanhol é a lingua oficial da Argentina.")
  def times_futebol(self):
    print("Os times Boca Junior e River Plate são da Argentina.")

class Brasil():
  def capital(self):
    print("Brasilia é a capital do Brasil.")
  def lingua_oficial(self):
    print("O portugues é a lingua oficial do Brasil.")
  def times_futebol(self):
    print("Os times Corinthians e Flamengo são do Brasil.")


obj_arg = Argentina()
obj_bra = Brasil()
for pais in (obj_arg, obj_bra):
  pais.capital()
  pais.lingua_oficial()
  pais.times_futebol()

# Exemplo de Polimorfismo
class Veiculo:
  def rodar(self):
    print("Reduz o consumo de combustivel.")

class VeiculoEletrico(Veiculo):
  def rodar(self):
    super().rodar()
    print("Esse veículo utiliza Eletricidade.")

veiculo_eletrico = VeiculoEletrico()
veiculo_eletrico.rodar()

# Exemplo de Exceção:
x = 10
if x > 5:
  raise Exception('X não pode ser maior do que 5. O valor de x foi de: {}'.format(x))

"""# **MÓDULO 4**

Exercícios de orientação a objetos

- **toStr =** Transforma o resultado desejado em string

- Para deinir um elemente **privado** inserir um underscore na frente (_)
"""

# EXERCICIO 1) Implantar um programa para criar uma classe veiculos com atributos de instância "velocidade maxima" e "KM por litro"

# CRIANDO A CLASSE VEICULOS
class Veiculo:

    def __init__(self, nome, velocidade_max, km_litro):
        self.nome = nome
        self.velocidade_max = velocidade_max
        self.km_litro = km_litro

    def to_str(self):
        print(f'nome = {self.nome}')
        print(f'velocidade_max = {self.velocidade_max}')
        print(f'Quilometros percorridos por litro = {self.km_litro}')

modelo_carro = Veiculo("Virtus Tsi", 180, 15)
modelo_carro.to_str()

# EXERCICIO 2) Crie uma classe filha "Onibus" que herdará todas as variaveis e métodos da classe "Veiculo"
class Onibus(Veiculo):
  pass
onibus_escolar = Onibus("Scania", 120, 8)
onibus_escolar.to_str()

# EXERCICIO 3) Modificar a classe filha "Onibus", de modo que ele forneça a qtd de assentos sendo esse valor 70

class Veiculo:

    def __init__(self, nome, velocidade_max, km_litro):
        self.nome = nome
        self.velocidade_max = velocidade_max
        self.km_litro = km_litro

    def capacidade_assentos(self, capacidade):
      print(f'A capacidade máxima de assentos do veiculo {self.nome} é {capacidade}')

    def to_str(self):
        print(f'nome = {self.nome}')
        print(f'velocidade_max = {self.velocidade_max}')
        print(f'Quilometros percorridos por litro = {self.km_litro}')

class Onibus(Veiculo):
    def capacidade_assentos(self, capacidade=70):
      return super().capacidade_assentos(capacidade=70)


onibus_escolar = Onibus("Scania", 130, 8)
onibus_escolar.to_str()
onibus_escolar.capacidade_assentos()

"""**Comparação entre as linguagens C++, Java e Python**"""

# JAVA
public class Cliente {
    private float saldo;
    public String nome;
    protected String referencia;}


# C ++
class Cliente {
private:
  float saldo;
public:
  char* nome; }


# PYTHON
class Cliente:
  def __init__(self):
    self.nome = "";
    self._saldo = 0.0;

# HERNAÇA MULTIPLA

# PYTHON
class ContaRemunerada (Conta, Poupanca):

# C ++
class ContaRemunerada:
      public Conta,
      public Poupanca {}

# JAVA
interface Conta {}
interface Poupanca{}
class ContaRemunerada "implements" # Deve se usar o implements as duas interfaces.
      Conta, Poupanca {}
# herança com extends

# POLIMORFISMO

# JAVA
class Profissional extends Pessoa {
    @Override #Override quer dizer sobrescrita
    public void imprimir () {
        super.imprimir();
        ....}
}

# C ++
class Profissional: public Pessoa {
    virtual void imprimir {
        Pessoa: :imprimir ():
        .... };
}


# PYTHON
class Profissional(Pessoa):
  def imprimir():
    super() .imprimir()