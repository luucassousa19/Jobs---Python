# -*- coding: utf-8 -*-
"""TEMA 4 - Python Estruturado .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ydR9MMnnZN1wcO3vt3zAD5D4iGav9seL

# **MODULO 1**

Emprego de estruturas de decisão e repetição
"""

# Estratégia 01
a = 10
b = 20

if(a > b):
  maior = a
else:
  maior = b
print(f'O maior número é {maior}')

# Estratégia 02
a = 10
b = 20

maior = a
if(b > maior):
  maior = b
print(f'O maior número é {maior}')

# Exercicio 1) Criar uma solução para verificar se um número é par ou ímpar
numero = 25

if(numero%2==0):
  situacao = "O número é par"
else:
  situacao = "O número é impar"

print(situacao)



# if(numero%2==0):: Esta linha verifica se o número é par. A operação numero % 2 calcula o resto da divisão de numero por 2. Se o resto for 0, o número é par.
# situacao = "O número é par": Se a condição numero % 2 == 0 for verdadeira, a variável situacao é definida como "O número é par".
# else:: Se a condição não for verdadeira (ou seja, se numero % 2 != 0), o código no bloco else será executado.
# situacao = "O número é impar": Neste caso, a variável situacao é definida como "O número é impar".

# Exercicio 2) Implementar um solução que resolva a seguinte questão:
# se nota for maior ou igual a 7 = aprovado
# se nota for menor que 7 ou igual a 5 = recuperação
# se nota for menor que 5 = reprovado

media = 6.9

if (media > 7.0):
  situacao = "Aprovado"
elif (media >= 5.0):
  situacao = "em Recuperação"
else:
  situacao = "Reprovado"

print(f'O Aluno está: {situacao}')

# Se a variável media for maior que 7.0, a condição é verdadeira e a variável situacao é definida como "Aprovado".
# Se a condição if não for verdadeira (ou seja, media não é maior que 7.0), a condição elif é avaliada. Se media for maior ou igual a 5.0, a variável situacao é definida como "em Recuperação".
# Se nenhuma das condições anteriores for verdadeira (ou seja, media é menor que 5.0), a variável situacao é definida como "Reprovado".

"""# **MODULO 2**

Emprego de procedimentos e funções
"""

# Exercicio 03) Implementar um solução que resolva a seguinte questão:
# calcular o valor de uma compra, sendo que o preço unitário é R$10,00
# compra de até 10 und - sem desconto
# compras entre 11 e 20 und - 10% de desconto
# compras acima de 20 und - 20% de desconto

preco_unitario = 10
DESCONTO10 = 0.1
DESCONTO20 = 0.2
quantidade = eval(input("Digite a quantidade que vai comprar: "))

if(quantidade <=10): #menor ou igual a 10
  valor_final = preco_unitario * quantidade

elif(quantidade <=20): #maior que 10 e menor ou igual a 20
  valor_final = preco_unitario * quantidade * (1 - DESCONTO10)
else: #maior que 20
  valor_final = preco_unitario * quantidade * (1 - DESCONTO20)

print(f'O valor final da compra é: `{valor_final}')

# Exercicio 04) Implementar um solução que some todos os números pares de uma lista:

lista = [10,2,5,7,6,3]

#Estrategia 01
n = len(lista)
soma = 0
for i in range(n):
  if(lista[i]%2==0):
    soma = soma + lista[i]

print(f'O somatorio dos elementos pares da lista é: {soma}')

# Obtenção do comprimento da lista: n = len(lista) - calcula o número de elementos na lista lista e armazena esse valor na variável n.
# Inicialização da soma: soma = 0  - inicializa a variável soma com o valor 0. Esta variável será usada para acumular a soma dos números pares da lista.
# Iteração sobre a lista: for i in range(n): - Este laço for percorre todos os índices da lista, de 0 até n-1.
# Verificação de números pares: if(lista[i]%2==0):  - Dentro do laço, esta linha verifica se o elemento atual da lista é par. O operador % calcula o resto da divisão do elemento por 2. Se o resto for 0, o número é par.
# Acumulação da soma dos números pares: soma = soma + lista[i] - Se o elemento da lista for par, ele é adicionado à variável soma.

#Estrategia 02
soma = 0
for num in lista:
  if(num%2==0):
    soma = soma + num

print(f'O somatorio dos elementos pares da lista é: {soma}')

# Inicialização da variável soma: soma = 0 - inicializa a variável soma com o valor 0. Esta variável será usada para acumular a soma dos números pares da lista.
# Laço for para iterar sobre os elementos da lista: for num in lista: - Este laço for percorre todos os elementos da lista lista, atribuindo cada elemento à variável num em cada iteração.
# Verificação de números pares: if(num%2==0): - Dentro do laço, esta linha verifica se o elemento atual (num) é par. O operador % calcula o resto da divisão do número por 2. Se o resto for 0, o número é par.
# Acumulação da soma dos números pares: soma = soma + num - Se a condição if for verdadeira (ou seja, se num for par), o valor de num é adicionado à variável soma.

# EMPREGO DE PROCEDIMENTOS E FUNÇÕES:

#EXEMPLO: Implementar uma solução em Python que retorne o menor elemento da lista.

def encontrar_minimo(lista):
  minimo = lista[0]
  for elem in lista:
      if(elem < minimo):
        minimo = elem
  return minimo

lista_teste = [0.5,2,10,3,1,4,5]
menor = encontrar_minimo(lista_teste)
print("O menor elemento da lista é:[{}]".format(menor))


# Definição da função encontrar_minimo: def encontrar_minimo(lista): - Esta linha define uma função chamada encontrar_minimo que recebe um argumento lista.
# Inicialização da variável minimo: minimo = lista[0] - A variável minimo é inicializada com o primeiro elemento da lista. Isso pressupõe que a lista não está vazia.
# Laço for para iterar sobre os elementos da lista: for elem in lista: - Este laço for percorre todos os elementos da lista lista, atribuindo cada elemento à variável elem em cada iteração.
# Verificação e atualização do menor elemento: if(elem < minimo): minimo = elem - Dentro do laço, esta condição verifica se o elemento atual (elem) é menor que o valor atual de minimo. Se a condição for verdadeira, minimo é atualizado para o valor de elem.
# Retorno do menor elemento: return minimo - Após o término do laço for, a função retorna o valor de minimo, que é o menor elemento encontrado na lista.
# Criação de uma lista de teste: lista_teste = [0.5, 2, 10, 3, 1, 4, 5] - Aqui, uma lista de teste chamada lista_teste é criada com alguns valores.
# Chamada da função encontrar_minimo e armazenamento do resultado: menor = encontrar_minimo(lista_teste) - A função encontrar_minimo é chamada com lista_teste como argumento, e o resultado é armazenado na variável menor.
# Impressão do menor elemento da lista: print("O menor elemento da lista é:[{}]".format(menor)) - Esta linha imprime o menor elemento da lista usando a variável menor.

# EXERCICO 01) implementar uma solução que retorne a soma de todos os elementos pares de uma lista
def ehPar(n):
  r = (n%2==0)
  return r

def somar_par(lst):
  soma = 0
  for num in lst:
    if(ehPar(num)):
      soma=soma+num
  return soma

lista = [10,2,5,7,6,3]
soma = somar_par(lista)
print(f'O somatório dos elementos pares da lista é: {soma}')

#EXERCICIO 02) Implementar uma solução que calcule o fatorial de um número
#Estrategia 01
def fatorial_interativo(n):
  f=1
  for i in range(1,n+1):
    f=f*i
  return f

#Estrategia 02
def fatorial_recursivo(n):
  if((n==0) or (n==1)):
    return 1
  return n*fatorial_recursivo(n-1)

numero = 5
print(f'O fatorial de {numero} é: {fatorial_interativo(numero)}')
print(f'O fatorial de {numero} é: {fatorial_recursivo(numero)}')

#EXERCICIO 03) Implementa uma solução que determine se um número é ou nao primo
def eh_primo(n):
  if(n < 2):
    return False
  i = n//2
  while(i > 1):
    if(n%i==0):
      return False
    i = i - 1
  return True

def imprimir_resultado(numero, resultado):
  mensagem= f'O número {numero} Não é primo'
  if(resultado):
    mensagem= f'O número {numero} é primo'
  return mensagem

numero = 6
resultado = eh_primo(numero)
msg = imprimir_resultado(numero, resultado)
print(msg)

"""# **MODULO 3**
Aplicando as bibliotecas Python para a resolução de problemas reais
"""

#Importando bibliotecas PY
import numpy as np

#Exemplo - Implementando solução para calcular raizes de uma equação de segundo grau
def entrada_dados():
  coeficiente = quantidade = eval(input("Digite o Valor do coeficiente: "))
  return coeficiente

def calc_delta(a,b,c):
  delta = b*b - 4*a*c
  return delta

def calcular_raizes(a,b,c,delta):
  if(delta < 0):
    resultado='a equação não possui raízes nos números reais'
  elif(delta == 0):
    x = -b / (2*a)
    resultado=f'a equação possui apenas a raiz: {x}'
  else:
    x1 = (-b - np.sqrt(delta)) / (2 * a)
    x2 = (-b + np.sqrt(delta)) / (2 * a)
    resultado=f'a equação possui as raizes {x1}, {x2}'
  return resultado

a = entrada_dados()
b = entrada_dados()
c = entrada_dados()

delta = calc_delta(a,b,c)

resultado = calcular_raizes(a,b,c,delta)
print(resultado)

# Exercicio 01) Implementar uma solução para visualizar dados de vendas  de produtos em um grafico de barras:
# Dados abaixo:
x = ["A","B","C","D"]
y = [3,8,1,10]

import matplotlib.pyplot as plt
import numpy as np

x = np.array (["A","B","C","D"])
y = np.array ([3,8,1,10])

plt.bar(x,y)
plt.show()

np.random.seed(1)
dados = np.random.normal(loc=20,scale=2, size=1000)
plt.hist(dados, color = "lightblue", ec="red")

"""# **MODULO 4**
Tratamento de exceções na linguagem Python
"""

# Implementar uma solução que faça o tratamento de exceção p/ verificar se a entrada é de fato um número

try:
  x = int(input("Digite um número: "))
except ValueError:
  print("Entre com um número válido")

# EXERCICIO 01) Implementar solução que faça o tratamento de exceção para verificar  se uma entrada
# é numerica  e insista que o usuario digite um numero valido:
while True:
  try:
    x = int(input("Digite um número: "))
    break
  except ValueError:
    print("Entre com um número válido")

# EXERCICIO 02) Implementar uma solução que faça o tratamento de exceção de divisão por zero

def dividir(x,y):
  try:
    resultado = x / y
    print("A resposta é:", resultado)
  except ZeroDivisionError:
    print("Divisão por zero")

dividir(3,2)

